package com.venomgrave.hexvg.schematic;

import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.block.Block;
import org.bukkit.block.data.BlockData;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;


public final class SchematicSaver {

    private SchematicSaver() {}

    public static void save(World world, Location pos1, Location pos2, File outputFile, String name, int lootMin, int lootMax) throws IOException {

        int minX = Math.min(pos1.getBlockX(), pos2.getBlockX());
        int minY = Math.min(pos1.getBlockY(), pos2.getBlockY());
        int minZ = Math.min(pos1.getBlockZ(), pos2.getBlockZ());
        int maxX = Math.max(pos1.getBlockX(), pos2.getBlockX());
        int maxY = Math.max(pos1.getBlockY(), pos2.getBlockY());
        int maxZ = Math.max(pos1.getBlockZ(), pos2.getBlockZ());

        int width  = maxX - minX + 1;
        int height = maxY - minY + 1;
        int length = maxZ - minZ + 1;

        List<String> blockLines = new ArrayList<>();

        for (int y = minY; y <= maxY; y++) {
            for (int z = minZ; z <= maxZ; z++) {
                for (int x = minX; x <= maxX; x++) {
                    Block block = world.getBlockAt(x, y, z);
                    Material mat = block.getType();

                    if (mat.isAir()) continue; // AIR pomijamy

                    int ry = y - minY;
                    int rz = z - minZ;
                    int rx = x - minX;

                    String line = buildBlockLine(block, ry, rz, rx);
                    if (line != null) blockLines.add(line);
                }
            }
        }

        outputFile.getParentFile().mkdirs();
        try (Writer w = new OutputStreamWriter(new FileOutputStream(outputFile), StandardCharsets.UTF_8)) {

            w.write("# Generated by HexVG-Planets SchematicSaver\n");
            w.write("# Date: " + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()) + "\n");
            w.write("# Area: " + width + "x" + height + "x" + length + " (w x h x l), " + blockLines.size() + " blocks\n");
            w.write("name: " + sanitizeName(name) + "\n");
            w.write("size: " + width + " " + height + " " + length + "\n");
            w.write("loot: " + lootMin + " " + lootMax + "\n");
            w.write("blocks:\n");
            for (String bl : blockLines) {
                w.write(bl);
                w.write("\n");
            }
        }
    }

    public static void save(World world, Location pos1, Location pos2,
                            File outputFile, String name) throws IOException {
        save(world, pos1, pos2, outputFile, name, 3, 10);
    }

    public static Schematic capture(World world, Location pos1, Location pos2, String name, int lootMin, int lootMax) {

        int minX = Math.min(pos1.getBlockX(), pos2.getBlockX());
        int minY = Math.min(pos1.getBlockY(), pos2.getBlockY());
        int minZ = Math.min(pos1.getBlockZ(), pos2.getBlockZ());
        int maxX = Math.max(pos1.getBlockX(), pos2.getBlockX());
        int maxY = Math.max(pos1.getBlockY(), pos2.getBlockY());
        int maxZ = Math.max(pos1.getBlockZ(), pos2.getBlockZ());

        int width  = maxX - minX + 1;
        int height = maxY - minY + 1;
        int length = maxZ - minZ + 1;

        SchematicBlock[][][] blocks = new SchematicBlock[height][length][width];

        for (int y = 0; y < height; y++)
            for (int z = 0; z < length; z++)
                for (int x = 0; x < width; x++)
                    blocks[y][z][x] = SchematicBlock.AIR;

        for (int y = minY; y <= maxY; y++) {
            for (int z = minZ; z <= maxZ; z++) {
                for (int x = minX; x <= maxX; x++) {
                    Block block = world.getBlockAt(x, y, z);
                    Material mat = block.getType();
                    if (mat.isAir()) continue;

                    int ry = y - minY;
                    int rz = z - minZ;
                    int rx = x - minX;

                    blocks[ry][rz][rx] = blockToSchematicBlock(block);
                }
            }
        }

        return new Schematic(name, width, height, length, lootMin, lootMax, blocks);
    }

    private static String buildBlockLine(Block block, int ry, int rz, int rx) {
        Material mat = block.getType();

        if (mat == Material.SPAWNER) {
            String entityType = getSpawnerEntityType(block);
            return ry + " " + rz + " " + rx + " SPAWNER " + entityType;
        }

        if (isLootChest(mat)) {
            String bd = getBlockDataString(block);
            return ry + " " + rz + " " + rx + " " + mat.name() +
                    (bd != null ? " " + bd : "");
        }

        String bd = getBlockDataString(block);
        if (bd != null) {
            return ry + " " + rz + " " + rx + " " + mat.name() + " " + bd;
        }

        return ry + " " + rz + " " + rx + " " + mat.name();
    }

    private static SchematicBlock blockToSchematicBlock(Block block) {
        Material mat = block.getType();

        if (mat == Material.SPAWNER) {
            return SchematicBlock.spawner(getSpawnerEntityType(block));
        }

        String bd = getBlockDataString(block);
        return new SchematicBlock(mat, bd);
    }

    private static String getBlockDataString(Block block) {
        BlockData data = block.getBlockData();
        String dataStr = data.getAsString();

        if (!dataStr.contains("[")) return null; // brak właściwości → null

        if (dataStr.contains("[snowy=false]")) return null;

        return dataStr;
    }

    private static String getSpawnerEntityType(Block block) {
        try {
            if (block.getState() instanceof org.bukkit.block.CreatureSpawner) {
                org.bukkit.block.CreatureSpawner cs = (org.bukkit.block.CreatureSpawner) block.getState();
                org.bukkit.entity.EntityType et = cs.getSpawnedType();
                if (et != null) return et.name();
            }
        } catch (Exception ignored) {}
        return "ZOMBIE";
    }

    private static boolean isLootChest(Material mat) {
        return mat == Material.CHEST || mat == Material.TRAPPED_CHEST || mat == Material.BARREL || mat == Material.SHULKER_BOX || mat == Material.WHITE_SHULKER_BOX;
    }

    private static String sanitizeName(String name) {
        if (name == null) return "unnamed";
        return name.replaceAll("[^a-zA-Z0-9_\\-]", "_").toLowerCase();
    }
}